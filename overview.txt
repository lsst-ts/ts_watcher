Overview (this will be incorporated into the sphinx documentation):

The Watcher is a CSC that monitors SAL components and generates alarm events which are
intended to be displayed on the LOVE interface.
The Watcher requiremens are document LTS-897 and the rationale for having a Watcher is described here: https://confluence.lsstcorp.org/display/LTS/The+Watcher%3A+A+Proposal.

The most fundamental objects that make up the Watcher are rules and alarms. Rules monitor topics from remote SAL components and, based on that information, set the severity of alarms. Alarms contains the state of an alarm, including the current severity, whether the alarm has been acknowledged, and the maximum severity seen since last acknowledgement. Rules are instances of subclasses of base.BaseRule. Alarms are instances of base.Alarm.

There is a one to one relationship between rules and alarms; every rule contains an associated alarm.

Rules set alarm severity in one of two ways:

* Most rules specify topics for which they are called when the topic receives a sample. The callback calls `BaseRule.__call__` which must return a tuple of (rule severity, reason). The calling code uses that information to set the alarm severity.
* A rule may also directly set the severity of its alarm by calling `self.alarm.set_severity`. One example is the `Heartbeat` rule which restarts a timer when a heartbeat event is received. If the timer expires the rule sets its alarm severity to `SERIOUS`. Another potential use case is a rule that polls data. A polling rule's `BaseRule.start` method starts a polling loop, and that loop reads the data and sets the alarm state.

Each alarm must have a unique name.
This name is displayed in LOVE and is used to aknowledge alarms.
The convention for rule names is rule_class_name.remote_name_index, where rule_class_name is the class name of a rule relative to `lsst.ts.watcher.rule`. For example `Heartbeat.ATDome:0` or `test.ConfiguredSeverities.ScriptQueue:1`.
That same rule class name is how a rule is specified in the Watcher's configuration file.

Many rule classes can define more than one rule; for example the Enabled rule monitors whether a CSC is in the ENABLED state, and there is instance of the Enabled rule for each CSC being monitored.

Rules can be configured.
For instance the Enabled rule is configured with the name and index of the CSC that it monitors.
The configuration is provided when the rule is instantiated and is validated against a schema specified by the rule as BaseRule.get_schema.

All rules must be defined in modules in the python/lsst/ts/watcher/rules directory or subdirectories.

The set of rules used by the Watcher and the configuration of each rule is specified by the CSC configuration.
A typical Watcher configuration file will specify most, but not all rules which are available, and will likely be large.
The Watcher configuration also has a list of disabled rules which is intended to make it easy to disable a few rules (e.g. when a subsystem is down) without having to delete the configuration for those rules from the configuration file.

The Model class manages all the rules that are in use.
It is the model that uses the watcher configuration to construct rules, construct salobj Remotes and wire everything together.
The model also disables rules when the Watcher CSC is not in the ENABLED state.


Subtleties, or What Are Those Support Classes?

In order to reduce resource usage, Remotes and Topics are only constructed if needed and are shared if possible.
Thus if more than one rule needs a given Remote, only one instance of that Remote is constructed.
It follows that if more than one rule needs a Topic, only one instance is constructed.

The TopicCallback class is used to support calling more than one rule from a topic. This is needed because a topic can only call back to a single function.

Since rules share remotes and topics, the rule's constructor does not construct remotes or topics (which also means that a rule's constructor does not make the rule fully functional).
Instead a rule specifies the topics it needs by constructing RemoteInfo objects, which the Model uses to construct the remotes and topics and connect them to the rule.

Rules are isolated from each other in two ways, both of which are implemented by wrapping each remote with multiple instances of RemoteWrapper, one instance per rule that uses the remote:

* A rule can only see the topics that it specifies it wants. This eliminates a source of surprising errors where rule A uses a topic specified by rule B. The topic will only be available to rule A if rule B is being used.
* A rule can only see the current value of a topic; it cannot wait on the next value of a topic. That prevents one rule from stealing data from another rule.

The basic pattern in the Model:
- Parse the configuration.
- For each rule specified in the config:
  - Construct the Rule, passing in the specified configuration.
  - For each RemoteInfo the rule specifies, connect the rule to an existing Remote (if possible) or construct new one (if not), and add topics to the remote if necessary.
    Also construct a RemoteWrapper and attach it to the rule.
- Once all rules are constructed, call ``start`` on each Remote to start it reading.
- Enable all rules when the Watcher is enabled and disable them otherwise.

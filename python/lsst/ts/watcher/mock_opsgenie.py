from __future__ import annotations

# This file is part of ts_watcher.
#
# Developed for Vera C. Rubin Observatory Telescope and Site Systems.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
__all__ = ["MockOpsGenie"]

import os
import types
import typing
import uuid
from http import HTTPStatus

from aiohttp import web


def get_request_id() -> str:
    """Return a new unique request ID"""
    return str(uuid.uuid4())


def make_processing_reply(request_id: str) -> web.Reponse:
    """Make a standard "processing" reply.

    Parameters
    ----------
    request_id : `str`
        A request_id, as generated by get_request_id.
    """
    return web.json_response(
        data=dict(
            result="Request will be processed",
            took=0.01,
            requestId=request_id,
        ),
        status=HTTPStatus.ACCEPTED,
    )


class MockOpsGenie:
    """A mock OpsGenie service to support Watcher escalation in unit tests.

    Parameters
    ----------
    port : `int`
        The TCP/IP port for the service. 0 to choose a free port.

    Notes
    -----
    To use::

        async with MockOpsGenie(port=...):
            # ... use the server

        # Or if you prefer explicit start/stop:

        genie = MockOpsGenie(port=...)
        await genie.start()
        # ... use the server
        await genie.cleanup()

    Attributes
    ----------
    port : `int`
        If the specified port is 0, then the chosen port
        (after `start` has run). Otherwise the specified port.
        The default is 80 because that is what OpsGenie uses.
    url : `str` | `None`
        The root URL of the service. None until `start` has run.
    """

    def __init__(self, port: int = 80) -> None:
        self.port = port
        self.escalation_key = os.environ["ESCALATION_KEY"]
        # Dict of alert ID: data_dict
        self.alerts: dict[str, dict] = dict()
        self.runner: web.AppRunner | None = None
        self.site: web.TCPSite | None = None
        self.url: str | None = None
        # Unit tests may set this True to reject the next request
        self.reject_next_request = False

    def make_app(self) -> web.Application:
        """Make an instance of the web application."""
        app = web.Application()
        app.add_routes(
            [
                web.post("/:{identifier}/close", self.close_alert),
                web.post("/", self.create_alert),
                web.delete("/:{identifier}", self.delete_alert),
            ]
        )
        return app

    async def start(self) -> None:
        """Start the service.

        Raises
        ------
        RuntimeError
            If port = 0 and serving on more than one socket
            (in which case the served port cannot be determined).
        """
        if self.runner is not None:
            raise RuntimeError("Already started")
        app = self.make_app()
        self.runner = web.AppRunner(app)
        await self.runner.setup()
        self.site = web.TCPSite(self.runner, "127.0.0.1", port=self.port)
        await self.site.start()
        server = self.site._server
        if self.port == 0:
            if len(server.sockets) != 1:
                raise RuntimeError(
                    "Serving on more than one socket; cannot determine the port"
                )
            self.port = server.sockets[0].getsockname()[1]  # type: ignore
        self.url = f"http://127.0.0.1:{self.port}"

    async def cleanup(self) -> None:
        """Stop the service."""
        if self.runner is None:
            raise RuntimeError("No runner; did you call start?")
        await self.runner.cleanup()

    def assert_authorized(self, request: web.Request) -> None:
        """Raise an error if self.reject_next_request true or not authorized.

        Always reset self.reject_next_request to False.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.

        Raises
        ------
        HTTPInternalServerError
            If self.reject_next_request True.
        Raise HTTPForbidden
            If the request is not authorized.
        """
        if self.reject_next_request:
            self.reject_next_request = False
            raise web.HTTPInternalServerError(
                text="Failed by request: reject_next_request true"
            )

        auth_header = request.headers.get("Authorization", None)
        if auth_header is None:
            raise web.HTTPForbidden(text="No Authorization header")
        try:
            name, value = auth_header.split(None, 1)
        except ValueError:
            raise web.HTTPForbidden(
                text="Authorization header must be of the form 'GenieKey <key>'"
            )
        if name != "GenieKey":
            raise web.HTTPForbidden(
                text="Authorization header must start with GenieKey"
            )
        if value != self.escalation_key:
            raise web.HTTPForbidden(text="Authorization key does not match")

    async def close_alert(self, request: web.Request) -> web.json_response:
        """Request handler to set the status of an alert to "closed".

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        identifier = request.match_info["identifier"]
        alert_data = self.alerts.get(identifier, None)
        if alert_data is not None:
            alert_data["status"] = "closed"
        request_id = get_request_id()
        return make_processing_reply(request_id=request_id)

    async def create_alert(self, request: web.Request) -> web.json_response:
        """Request handler to create a new alert.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        alert_data = await request.json()
        request_id = get_request_id()
        alert_data["status"] = "open"
        alert_data["id"] = request_id
        self.alerts[request_id] = alert_data
        return make_processing_reply(request_id=request_id)

    async def delete_alert(self, request: web.Request) -> web.json_response:
        """Request handler to delete an alert.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        identifier = request.match_info["identifier"]
        self.alerts.pop(identifier, None)
        request_id = get_request_id()
        return make_processing_reply(request_id=request_id)

    async def __aenter__(self) -> MockOpsGenie:
        await self.start()
        return self

    async def __aexit__(
        self,
        type: None | typing.Type[BaseException],
        value: None | BaseException,
        traceback: None | types.TracebackType,
    ) -> None:
        await self.cleanup()

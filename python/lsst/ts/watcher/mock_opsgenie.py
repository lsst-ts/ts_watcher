from __future__ import annotations

# This file is part of ts_watcher.
#
# Developed for Vera C. Rubin Observatory Telescope and Site Systems.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
__all__ = ["MockOpsGenie"]

import os
import types
import typing
import uuid
from http import HTTPStatus

from aiohttp import web


def get_request_id() -> str:
    """Return a new unique request ID"""
    return str(uuid.uuid4())


def make_processing_reply(request_id: str) -> web.Reponse:
    """Make a standard "processing" reply.

    Parameters
    ----------
    request_id : `str`
        A request_id, as generated by get_request_id.
    """
    return web.json_response(
        data=dict(
            result="Request will be processed",
            took=0.01,
            requestId=request_id,
        ),
        status=HTTPStatus.ACCEPTED,
    )


class MockOpsGenie:
    """A mock OpsGenie service to support Watcher escalation in unit tests.

    Parameters
    ----------
    port : `int`
        The TCP/IP port for the service. 0 to choose a free port.
        The default is 80 because that is what OpsGenie uses.

    Notes
    -----
    To use::

        async with MockOpsGenie(port=...) as server:
            # ... use the server

        # Or if you prefer explicit start/stop:

        server = MockOpsGenie(port=...)
        await server.start()
        # ... use the server
        await server.close()

    Raises
    ------
    `RuntimeError`
        If env var ``ESCALATION_KEY`` not set.

    Attributes
    ----------
    port : `int`
        If the specified port is 0, then the chosen port
        (after `start` has run). Otherwise the specified port.
        The default is 80 because that is what OpsGenie uses.
    url : `str` | `None`
        The root URL of the service. "" until `start` has run.
    escalation_key : `str`
        The value of env var ESCALATION_KEY.
    alerts : `dict` [`str`, `dict`]
        Dict of alert ID: alert data in OpsGenie's format.
        The following keys should be in the sent data:

        * message (str): a summary of the problem
        * description (str): a detailed description of the problem
        * responders (list[dict[str, str]]): a list of responders,
          each of which is a dict with two keys:,

          * type (str): one of "user" or "team" (or some other value
            Watcher will not use).
          * id (str): user email address; only present if type is "user"
          * name (str): team name; only present if type is "team"

        The OpsGenie service the following two keys:

        * id (str): a unique alert ID
        * status (str): one of "open" or "closed"
          (the real OpsGenie service has additional statuses).

    reject_next_request : `bool`
        If the user sets this true then the mock will reject the next request
        with `web.HTTPInternalServerError` and reset this flag. For unit tests.
    """

    def __init__(self, port: int = 80) -> None:
        self.port = port
        try:
            self.escalation_key = os.environ["ESCALATION_KEY"]
        except KeyError:
            raise RuntimeError("env variable ESCALATION_KEY must be set")
        self.alerts: dict[str, dict] = dict()
        self.url: str = ""
        self.reject_next_request = False
        self._runner: web.AppRunner | None = None
        self._site: web.TCPSite | None = None

    def make_app(self) -> web.Application:
        """Make an instance of the web application."""
        app = web.Application()
        app.add_routes(
            [
                web.post("/:{identifier}/close", self.close_alert),
                web.post("/", self.create_alert),
                web.delete("/:{identifier}", self.delete_alert),
            ]
        )
        return app

    async def start(self) -> None:
        """Start the service.

        Raises
        ------
        `RuntimeError`
            If port = 0 and serving on more than one socket
            (in which case the served port cannot be determined),
            or if this method has already been called.
        """
        if self._runner is not None:
            raise RuntimeError("Already started")
        app = self.make_app()
        self._runner = web.AppRunner(app)
        await self._runner.setup()
        self._site = web.TCPSite(self._runner, "127.0.0.1", port=self.port)
        await self._site.start()
        server = self._site._server
        if self.port == 0:
            if len(server.sockets) != 1:
                raise RuntimeError(
                    "Serving on more than one socket; cannot determine the port"
                )
            self.port = server.sockets[0].getsockname()[1]  # type: ignore
        self.url = f"http://127.0.0.1:{self.port}"

    async def close(self) -> None:
        """Stop the service, if running."""
        if self._runner is None:
            await self._runner.cleanup()

    def assert_authorized(self, request: web.Request) -> None:
        """Raise an error if self.reject_next_request true or not authorized.

        Always reset self.reject_next_request to False.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.

        Raises
        ------
        `web.HTTPInternalServerError`
            If self.reject_next_request True.
        `web.HTTPForbidden`
            If the request is not authorized.
        """
        if self.reject_next_request:
            self.reject_next_request = False
            raise web.HTTPInternalServerError(
                text="Failed by request: reject_next_request true"
            )

        auth_header = request.headers.get("Authorization", None)
        if auth_header is None:
            raise web.HTTPForbidden(text="No Authorization header")
        try:
            name, value = auth_header.split(None, 1)
        except ValueError:
            raise web.HTTPForbidden(
                text="Authorization header must be of the form 'GenieKey {key}'"
            )
        if name != "GenieKey":
            raise web.HTTPForbidden(
                text="Authorization header must start with GenieKey"
            )
        if value != self.escalation_key:
            raise web.HTTPForbidden(text="Authorization key does not match")

    async def close_alert(self, request: web.Request) -> web.json_response:
        """Request handler to set the status of an alert to "closed".

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        identifier = request.match_info["identifier"]
        alert_data = self.alerts.get(identifier, None)
        if alert_data is not None:
            alert_data["status"] = "closed"
        request_id = get_request_id()
        return make_processing_reply(request_id=request_id)

    async def create_alert(self, request: web.Request) -> web.json_response:
        """Request handler to create a new alert.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        alert_data = await request.json()
        request_id = get_request_id()
        alert_data["status"] = "open"
        alert_data["id"] = request_id
        self.alerts[request_id] = alert_data
        return make_processing_reply(request_id=request_id)

    async def delete_alert(self, request: web.Request) -> web.json_response:
        """Request handler to delete an alert.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.
        """
        self.assert_authorized(request)
        identifier = request.match_info["identifier"]
        self.alerts.pop(identifier, None)
        request_id = get_request_id()
        return make_processing_reply(request_id=request_id)

    async def __aenter__(self) -> MockOpsGenie:
        await self.start()
        return self

    async def __aexit__(
        self,
        type: None | typing.Type[BaseException],
        value: None | BaseException,
        traceback: None | types.TracebackType,
    ) -> None:
        await self.close()

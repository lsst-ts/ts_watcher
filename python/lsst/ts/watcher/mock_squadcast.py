from __future__ import annotations

# This file is part of ts_watcher.
#
# Developed for Vera C. Rubin Observatory Telescope and Site Systems.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
__all__ = ["MockSquadCast"]

import json
import os
import types
import typing
import uuid
from http import HTTPStatus

from aiohttp import web

# The documentation says "30k" but how many bytes is this?
MAX_DATA_SIZE = 30000

# URL suffix for the Incident Webhook API
INCIDENT_WEBHOOK_URL_SUFFIX = "/v2/incidents/api/"


def get_incident_id() -> str:
    """Return a new unique request ID"""
    return str(uuid.uuid4())


def make_processing_reply(incident_id: str) -> web.Reponse:
    """Make a standard "processing" reply.

    Parameters
    ----------
    incident_id : `str`
        A incident_id, as generated by get_incident_id.
    """
    return web.json_response(
        data=dict(
            result="Request will be processed",
            took=0.01,
            requestId=incident_id,
        ),
        status=HTTPStatus.ACCEPTED,
    )


class MockSquadCast:
    """A mock SquadCast service to support Watcher escalation in unit tests.

    Parameters
    ----------
    port : `int`
        The TCP/IP port for the service. 0 to choose a free port.
        The default is 80 because that is what SquadCast uses.

    Raises
    ------
    `RuntimeError`
        If env var ``ESCALATION_KEY`` not set.

    Notes
    -----
    To use::

        async with MockSquadCast(port=...) as server:
            # ... use the server

        # Or if you prefer explicit start/stop:

        server = MockSquadCast(port=...)
        await server.start()
        # ... use the server
        await server.close()

    Known limitations:

    * SquadCast supports having multiple incidents with the same event_id.
      This mock does not -- it will reject creation of a new incident
      with a matching event ID.
    * SquadCast does not require the event_id field.
      This mock does, because it stores events by event_id.
    * SquadCast does not require the status field, based on tests,
      but the manual says nothing about it so I prefer to require it.
    * SquadCast does not require the "description" field when triggering an
      incident, but the manual says it is required. This emulates the manual.
    * The incidents dict is never purged, which is a memory leak, but emulates
      SquadCast. Thus this mock is intended for short-term unit tests,
      not long term emulation.

    Attributes
    ----------
    port : `int`
        The port. The port argument, except if that was 0 then this is
        updated to the chosen port when `start` is run.
    url : `str`
        The root URL of the service. "" until `start` has run.
    endpoint_url : `str`
        The URL of the endpoint (including the secret API key).
        "" until `start` has run.
    escalation_key : `str`
        The value of env var ESCALATION_KEY.
    incidents : `dict` [`str`, `dict`]
        Dict of event_id: incident data in SquadCast's format,
        which has these keys:

        * event_id (str): unique identifier
        * status (str): one of "trigger" or "resolve"
        * message (str): summary of the problem
        * details (str): additional information
        * tags (dict[str, dict[str, str]]): a dict of tag_name: value.

        These are keys that SquadCast uses. The first four are required
        and the mock does not check the rest of the data.
        Values for SquadCast "tags" can be str or dicts with a specific format,
        but Watcher only uses str values.
    reject_next_request : `bool`
        If the user sets this true then the mock will reject the next request
        with `web.HTTPInternalServerError` and reset this flag. For unit tests.
    """

    def __init__(self, port: int = 80) -> None:
        self.port = port
        try:
            self.escalation_key = os.environ["ESCALATION_KEY"]
        except KeyError:
            raise RuntimeError("env variable ESCALATION_KEY must be set")
        self.incidents: dict[str, dict] = dict()
        self.url: str = ""
        self.endpoint_url = ""
        self.reject_next_request = False
        self._runner: web.AppRunner | None = None
        self._site: web.TCPSite | None = None

    def make_app(self) -> web.Application:
        """Make an instance of the web application."""
        app = web.Application()
        url_suffix = INCIDENT_WEBHOOK_URL_SUFFIX + self.escalation_key
        app.add_routes([web.post(url_suffix, self.incident_webhook)])
        return app

    async def start(self) -> None:
        """Start the service.

        Raises
        ------
        `RuntimeError`
            If port = 0 and serving on more than one socket
            (in which case the served port cannot be determined),
            or if this method has already been called.
        """
        if self._runner is not None:
            raise RuntimeError("Already started")
        app = self.make_app()
        self._runner = web.AppRunner(app)
        await self._runner.setup()
        self._site = web.TCPSite(self._runner, "127.0.0.1", port=self.port)
        await self._site.start()
        server = self._site._server
        if self.port == 0:
            if len(server.sockets) != 1:
                raise RuntimeError(
                    "Serving on more than one socket; cannot determine the port"
                )
            self.port = server.sockets[0].getsockname()[1]  # type: ignore
        self.url = f"http://127.0.0.1:{self.port}"
        self.endpoint_url = self.url + INCIDENT_WEBHOOK_URL_SUFFIX + self.escalation_key

    async def close(self) -> None:
        """Stop the service, if running."""
        if self._runner is not None:
            await self._runner.cleanup()

    async def incident_webhook(self, request: web.Request) -> web.json_response:
        """Request handler to trigger or resolve an incident.

        Parameters
        ----------
        request : `aiohttp.web.Request`
            Request.

        Raises
        ------
        `web.HTTPInternalServerError`
            If self.reject_next_request True.
        `web.HTTPRequestEntityTooLarge`
            If the request is too large.
        """
        if self.reject_next_request:
            self.reject_next_request = False
            raise web.HTTPInternalServerError(
                reason="Rejected because reject_next_request was true"
            )

        data = await request.json()
        json_data = json.dumps(data)
        if len(json_data) > MAX_DATA_SIZE:
            raise web.HTTPRequestEntityTooLarge(reason=f"data size > {MAX_DATA_SIZE}")

        # See Known limitations in class doc string for why these are required
        # despite not being required by the real SquadCast service.
        missing_fields = {"event_id", "status"} - data.keys()
        if missing_fields:
            raise web.HTTPBadRequest(
                reason=f"One or more required field are missing: {sorted(missing_fields)} in {data=}"
            )
        event_id = data["event_id"]
        command = data["status"]
        match command:
            case "trigger":
                # Create a new event
                if event_id in self.incidents:
                    raise web.HTTPBadRequest(
                        reason="An incident already exists with {event_id=}; rejecting the new incident"
                    )
                missing_fields = {"message", "description"} - data.keys()
                if missing_fields:
                    # TODO: what should this raise?
                    raise web.HTTPBadRequest(
                        reason=f"One or more required field are missing: {sorted(missing_fields)}"
                    )
                self.incidents[event_id] = data
            case "resolve":
                # TODO: is this an error? If so, what should it raise?
                incident = self.incidents.get(event_id, None)
                if incident is not None:
                    incident["status"] = "resolve"
            case _:
                raise RuntimeError(f"Unsupported status={command}")
        return make_processing_reply(incident_id=event_id)

    async def __aenter__(self) -> MockSquadCast:
        await self.start()
        return self

    async def __aexit__(
        self,
        type: None | typing.Type[BaseException],
        value: None | BaseException,
        traceback: None | types.TracebackType,
    ) -> None:
        await self.close()
